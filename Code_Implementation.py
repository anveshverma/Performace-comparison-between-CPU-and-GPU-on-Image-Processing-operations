# -*- coding: utf-8 -*-
"""Final_HPC.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v9Itn6H56sU82qCbsZbgguO7dT-znKXO
"""

import cv2
import time
import math
import glob
from google.colab.patches import cv2_imshow
import numpy as np
import cupy as cp
import numba
import matplotlib.pyplot as plt
from PIL import Image

# !unzip images.zip

def plot_comparison(d_s,d_p,title):
  plt.figure(figsize=(11,6))
  speedup = sum(d_s.values())/sum(d_p.values())
  print('Average Speedup:',str(int(speedup))+'x')
  x = sorted(list(map(int,d_s.keys())))
  y_s= [d_s[str(i)] for i in x]
  y_p= [d_p[str(i)] for i in x]
  labels = ['{}x{}'.format(i,i) for i in x]
  plt.plot(x,y_s,marker='o')
  plt.plot(x,y_p,marker='o')
  plt.xticks(x,labels,rotation=45)
  plt.xlabel('RESOLUTION')
  plt.ylabel('Time in ms')
  plt.legend(['Sequential','CUDA'])
  plt.title(title)
  plt.show

def adj_show(a,b):
  dim = a.shape
  dim_border = (a.shape[0],30) if len(dim)==2 else (a.shape[0],30,3)
  cv2_imshow(np.concatenate((a,255*np.ones(dim_border),b),axis=1))

images={}
for filename in glob.glob('*.jpg'):
    im=cv2.imread(filename)
    images[filename.split('.')[0]]=im
images.keys()

lamb = 150
threshold = 150

def grayscale_sequential(img):               #Sequential
  GI = []
  for i in range(img.shape[0]):
    l = []
    for j in range(img.shape[1]):
      l.append(sum(img[i][j])/3)
    GI.append(l)
  GI = np.array(GI)
  return GI

@numba.njit('float64[:,:](uint8[:,:,:])')        #CUDA backend
def grayscale_parallel(img):
  return (img[:,:,0]+img[:,:,1]+img[:,:,2])/3

#Calculating time (Sequential) - Grayscale
t_gray_seq = {}
out_gray_seq = {}
for name,image in images.items():
  start = time.time()
  out_gray_seq[name]=grayscale_sequential(image)
  t_gray_seq[name] =  time.time() - start
t_gray_seq

#Calculating time (Parallel) - Grayscale
t_gray_p = {}
out_gray_p = {}
for name,image in images.items():
  start = time.time()
  out_gray_p[name]=grayscale_parallel(images[name])
  t_gray_p[name] =  time.time() - start
t_gray_p

plot_comparison(t_gray_seq,t_gray_p,'Grayscale Conversion')

cv2_imshow(images['256'])
cv2_imshow(out_gray_p['256'])

def negative_sequential(img):         #Sequential
  NI = []
  for i in range(img.shape[0]):
    l = []
    for j in range(img.shape[1]):
      q = []
      for k in range(img.shape[2]):
        q.append(255-img[i][j][k])
      l.append(q)
    NI.append(l)
  NI = np.array(NI)
  return NI

@numba.vectorize('uint8(uint8)',target='parallel')           #CUDA backend
def negative_parallel(img):
  return 255-img

#Calculating time (Sequential) - Negative
t_neg_seq = {}
out_neg_seq = {}
for name,image in images.items():
  start = time.time()
  out_neg_seq[name]=negative_sequential(images[name])
  t_neg_seq[name] =  time.time() - start
t_neg_seq

#Calculating time (Parallel) - Negative
t_neg_p = {}
out_neg_p = {}
for name,image in images.items():
  start = time.time()
  out_neg_seq[name]=negative_parallel(images[name])
  t_neg_p[name] =  time.time() - start
t_neg_p

plot_comparison(t_neg_seq,t_neg_p,'Negative Filter Conversion')

adj_show(images['256'],out_neg_seq['256'])

def thresholding_sequential(img,threshold):           #Sequential
  G_th = []
  for i in range(img.shape[0]):
    l = []
    for j in range(img.shape[1]):
      l.append(255 if img[i][j] >= threshold else 0)
    G_th.append(l)
  G_th = np.array(G_th)
  return G_th

@numba.jit('float64[:,:](float64[:,:],float64[:,:],uint8)')             #Using CUDA jit decorator
def thresholding_parallel(img,out,threshold):
  for i in range(img.shape[0]):
    for j in range(img.shape[1]):
      if img[i,j] >= threshold:
        out[i,j] = 255.0
      else:
        out[i,j] = 0.0

  return out

#Calculating time (Sequential) - Thresholding
t_thr_seq = {}
out_thr_seq = {}
for name,image in out_gray_seq.items():
  start = time.time()
  out_thr_seq[name]=thresholding_sequential(out_gray_seq[name],threshold)
  t_thr_seq[name] =  time.time() - start
t_thr_seq

#Calculating time (Parallel) - Thresholding
t_thr_p = {}
out_thr_p = {}
for name,image in out_gray_seq.items():
  start = time.time()
  output = np.empty_like(out_gray_seq[name])
  out_thr_p[name]=thresholding_parallel(out_gray_seq[name],output,threshold)
  t_thr_p[name] =  time.time() - start
t_thr_p

plot_comparison(t_thr_seq,t_thr_p,'Thresholding Filter: Threshold={}'.format(threshold))

adj_show(out_gray_seq['256'],out_thr_seq['256'])

def brightening_sequential(img,lamb):       # Sequential
  BI = []
  ki = math.pi/(2*lamb)
  for i in range(img.shape[0]):
    l = []
    for j in range(img.shape[1]):
      q = []
      for k in range(img.shape[2]):
        q.append(lamb * math.sin(ki*img[i][j][k]))
      l.append(q)
    BI.append(l)
  BI = np.array(BI)
  return BI

@cp.fuse()                                       #CuPY FUSE decorator for creating CUDA Kernel
def brightening_parallel(img,lamb):
  xp = cp.get_array_module(img)
  ki = xp.pi/(2*lamb)
  return lamb * xp.sin(ki*img)

#Calculating time (Sequential) - Brightening
t_BI_seq = {}
out_BI_seq = {}
for name,image in images.items():
  start = time.time()
  out_BI_seq[name]=brightening_sequential(images[name],lamb)
  t_BI_seq[name] =  time.time() - start
t_BI_seq

#Calculating time (Parallel) - Brightening
t_BI_p = {}
out_BI_p = {}
for name,image in images.items():
  start = time.time()
  im_gpu = cp.asarray(images[name])
  out_gpu=brightening_parallel(im_gpu,lamb)
  out_BI_p[name] = out_gpu.get()
  t_BI_p[name] =  time.time() - start
t_BI_p

plot_comparison(t_BI_seq,t_BI_p,'Brightening Filter: Lambda={}'.format(lamb))

adj_show(images['256'],out_BI_seq['256'])

def darkening_sequential(img,lamb):             #Sequential
  DI = []
  ki = math.pi/(2*lamb)
  for i in range(img.shape[0]):
    l = []
    for j in range(img.shape[1]):
      q = []
      for k in range(img.shape[2]):
        q.append(lamb * (1-math.cos(ki*img[i][j][k])))
      l.append(q)
    DI.append(l)
  DI = np.array(DI)
  return DI

@cp.fuse()                                      #CuPY FUSE decorator for creating CUDA Kernel
def darkening_parallel(img,lamb):
  xp = cp.get_array_module(img)
  ki = xp.pi/(2*lamb)
  return lamb * (1-xp.cos(ki*img))

#Calculating time (Sequential) - Darkening
t_DI_seq = {}
out_DI_seq = {}
for name,image in images.items():
  start = time.time()
  out_DI_seq[name]=darkening_sequential(images[name],lamb)
  t_DI_seq[name] =  time.time() - start
t_DI_seq

#Calculating time (Parallel) - Darkening
t_DI_p = {}
out_DI_p = {}
for name,image in images.items():
  start = time.time()
  im_gpu = cp.asarray(images[name])
  out_gpu=darkening_parallel(im_gpu,lamb)
  out_DI_p[name] = out_gpu.get()
  t_DI_p[name] =  time.time() - start
t_DI_p

plot_comparison(t_DI_seq,t_DI_p,'Darkening Filter: Lambda={}'.format(lamb))

adj_show(images['256'],out_DI_seq['256'])

#Inverse Sinusoidal Contrast Image
def isci_sequential(img,lamb):
  ISCI = []
  ki = (2*math.pi)/255
  for i in range(img.shape[0]):
    l = []
    for j in range(img.shape[1]):
      q = []
      for k in range(img.shape[2]):
        q.append(img[i][j][k] - lamb*math.sin(ki*img[i][j][k]))
      l.append(q)
    ISCI.append(l)
  ISCI = np.array(ISCI)
  return ISCI

@cp.fuse()                              #CuPY FUSE decorator for creating CUDA Kernel
def isci_parallel(img,lamb):
  xp = cp.get_array_module(img)
  ki = (2*xp.pi)/255.0
  return img - lamb*xp.sin(ki*img)

#Calculating time (Sequential) - Inverse Sinusoidal Contrast
t_isci_seq = {}
out_isci_seq = {}
for name,image in images.items():
  start = time.time()
  out_isci_seq[name]=isci_sequential(images[name],lamb)
  t_isci_seq[name] =  time.time() - start
t_isci_seq

#Calculating time (Parallel) - Inverse Sinusoidal Contrast
t_isci_p = {}
out_isci_p = {}
for name,image in images.items():
  start = time.time()
  im_gpu = cp.asarray(images[name])
  out_gpu=isci_parallel(im_gpu,lamb)
  out_isci_p[name] = out_gpu.get()
  t_isci_p[name] =  time.time() - start
t_isci_p

plot_comparison(t_isci_seq,t_isci_p,'Inverse Sinusoidal Contrast Filter: Lambda={}'.format(lamb))

adj_show(images['256'],out_isci_seq['256'])

#Hyperbolic Tangent Contrast Image
def htci_sequential(img):                    #Sequential
  HTCI = []
  ki = 255/2
  start_time = time.time()
  for i in range(img.shape[0]):
    l = []
    for j in range(img.shape[1]):
      q = []
      for k in range(img.shape[2]):
        q.append(ki * (1 + math.tanh( img[i][j][k]-ki ) ))
      l.append(q)
    HTCI.append(l)
  HTCI = np.array(HTCI)
  return HTCI

@cp.fuse()                                          #CuPY FUSE decorator for creating CUDA Kernel
def htci_parallel(img):
  xp = cp.get_array_module(img)
  ki = 255.0/2.0
  return ki*(1+xp.tanh(img-ki))

#Calculating time (Sequential) - Hyperbolic Tangent
t_htci_seq = {}
out_htci_seq = {}
for name,image in images.items():
  start = time.time()
  out_htci_seq[name]=htci_sequential(images[name])
  t_htci_seq[name] =  time.time() - start
t_htci_seq

#Calculating time (Parallel) - Hyperbolic Tangent
t_htci_p = {}
out_htci_p = {}
for name,image in images.items():
  start = time.time()
  im_gpu = cp.asarray(images[name])
  out_gpu=htci_parallel(im_gpu)
  out_htci_p[name] = out_gpu.get()
  t_htci_p[name] =  time.time() - start
t_htci_p

plot_comparison(t_htci_seq,t_htci_p,'Hyperbolic Tangent Contrast Filter')

adj_show(images['256'],out_htci_p['256'],)

# def tryneg(img):
#   return 255-img

# @cp.fuse()
# def tryneg_p(img):
#   return 255-img

# t_tryneg_seq = {}
# out_tryneg_seq = {}
# for name,image in images.items():
#   start = time.time()
#   out_tryneg_seq[name]=tryneg(images[name])
#   t_tryneg_seq[name] =  time.time() - start
# t_tryneg_seq

# t_tryneg_p = {}
# out_tryneg_p = {}
# for name,image in images.items():
#   im_gpu = cp.asarray(images[name])
#   start = time.time()
  
#   out_gpu=tryneg_p(im_gpu)
  
#   t_tryneg_p[name] =  time.time() - start
#   out_tryneg_p[name] = out_gpu.get()
# t_tryneg_p

# plot_comparison(t_tryneg_seq,t_tryneg_p,'TryNeg')

# adj_show(images['256'],out_tryneg_p['256'])

